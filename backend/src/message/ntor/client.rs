use crate::message::ntor::common::{Certificate, generate_private_public_key_pair, InitSessionMessage, InitSessionResponse, PrivatePublicKeyPair};
use hmac::{Hmac, Mac};
use sha2::{Digest, Sha256};
use x25519_dalek::PublicKey;

pub struct Client {
    ephemeral_key_pair: PrivatePublicKeyPair,
    shared_secret: Option<Vec<u8>>,
}

impl Client {
    pub fn new() -> Self {
        let zero_bytes: [u8; 32] = [0; 32];

        Self {
            ephemeral_key_pair: PrivatePublicKeyPair {
                private_key: None,
                public_key: PublicKey::from(zero_bytes)
            },
            shared_secret: None,
        }
    }

    pub fn initialise_session(&mut self) -> InitSessionMessage {
        self.ephemeral_key_pair = generate_private_public_key_pair();

        InitSessionMessage {
            client_ephemeral_public_key: self.ephemeral_key_pair.public_key
        }
    }

    // Steps 15 - 20 of the Goldberg 2012 paper.
    pub fn handle_response_from_server(
        &mut self,
        server_certificate: &Certificate,
        msg: &InitSessionResponse,
    ) -> bool {
        println!("Client:");

        // Step 18: Compute the shared secret.
        let mut buffer: Vec<u8> = Vec::new();

        // ECDH Client private ephemeral * server static public key
        let taken_private_key = self.ephemeral_key_pair.private_key.take().unwrap();
        let mut ecdh_result_1 = taken_private_key.diffie_hellman(&msg.server_ephemeral_public_key).to_bytes().to_vec();
        println!("[Debug] ECDH result 1: {:?}", ecdh_result_1);
        buffer.append(&mut ecdh_result_1);

        // ECDH Client private ephemeral * server ephemeral public Key
        let mut ecdh_result_2 = taken_private_key.diffie_hellman(&server_certificate.public_key).to_bytes().to_vec();
        println!("[Debug] ECDH result 2: {:?}", ecdh_result_2);
        buffer.append(&mut ecdh_result_2);

        // Server id
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());

        // Client ephemeral public
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());

        // Server ephemeral public
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());

        // "ntor" string identifier
        buffer.append(&mut "ntor".as_bytes().to_vec());

        // Instantiate and run hashing function
        let mut hasher = Sha256::new();
        hasher.update(buffer);
        let sha256_hash = hasher.finalize();
        let sha256_hash: &[u8; 32] = match sha256_hash.as_slice().try_into() {
            Ok(array_ref) => array_ref,
            Err(_) => {
                panic!("Invalid sha256 hash length");
            }
        };

        let secret_key_prime = &sha256_hash[0..16];
        println!("[Debug] Client secret key prime: {:?}", secret_key_prime);

        let secret_key = &sha256_hash[16..];

        // Step 19: Compute HMAC (t_b in the paper)

        let mut buffer: Vec<u8> = Vec::new();
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());
        buffer.append(&mut "ntor".as_bytes().to_vec());
        buffer.append(&mut "server".as_bytes().to_vec());

        let mut hmac_hash = Hmac::<Sha256>::new_from_slice(&buffer).unwrap();
        hmac_hash.update(secret_key_prime);
        let computed_t_hash = hmac_hash.finalize().into_bytes().to_vec();

        // assert that computed_t_b_hash equals t_hash generated by server
        if computed_t_hash == msg.t_hash {
            self.shared_secret = Some(secret_key.to_vec());

            println!("Shared secret:");
            println!("{:?}\n", secret_key);
            true
        } else {
            println!("Failed to verify the shared secret: try again bro.");
            false
        }
    }

}